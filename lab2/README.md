# Лабораторная работа 2

# Все плохо с Докерфайлом

Плохой докерфайл

```
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y cowsay fortune
```
<img width="1412" height="276" alt="image" src="https://github.com/user-attachments/assets/c238c2f1-e73d-4b78-8be9-f7227b3f780a" />

Хороший докерфайл

```
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y cowsay fortune && rm -rf /var/lib/apt/lists/*
CMD ["/usr/games/cowsay", "Hello Lab2!"]
```
<img width="1666" height="310" alt="image" src="https://github.com/user-attachments/assets/358ffb5b-47a5-4ddc-963b-b3e492221911" />


## 1) Использованиие ```ubuntu:latest``` вмеcто специализированного образа

Многие использут используют эту инструкцию, чтобы указать на то, что в качестве базоваого образа для создания нового образа будет использоваться образ Ubuntu последней доступной версии из DockerHub.

Почему это плохая практика?

Несмотря на простоту, использование тега `latest` для образа означает, что сборка может внезапно прерваться при обновлении этого образа.


Грубо говоря,

<b>Сегодня</b>: Вы собираете Docker-образ, `ubuntu:latest` указывает, например, на Ubuntu 24.04. Сборка проходит успешно, приложение работает.

<b>Завтра(после выхода Ubuntu 24.10)</b>: образ `ubuntu:latest` на Docker Hub обновляется. Теперь он указывает на новую версию.

При следующей сборке будет использована совершенно другая версия. Это может привести к:

- сбою сборки: из-за изменений в пакетах, их версиях или расположении файлов.

- трудноуловимым ошибкам: приложение соберется, но будет вести себя непредсказуемо из-за незаметных изменений.


### Как исправить?

Используйте определенный тег образа(например, ubuntu:22.04), а еще лучше `ubuntu:22.04.3`. 

Это обеспечит неизменность Dockerfile.


А еще очень полезно использовать образы `slim` и `alpine`, так как они меньше места на жестком диске. 

<details>
<summary>Доп. инфа</summary>

`Slim образы` - образы, в которых присутствует минимальное количество пакетов и, в первую очередь, такие образы предназначены для запуска написанных программ.


`Alpine` образ содержит в себе одноименную операционную систему, разработанную специально для запуска внутри контейнера. Легковесность Alpine объясняется тем, что в данном дистрибутиве не используются привычные функции, которые доступны в других дистрибутивах Linux, такие как пакетные менеджеры apt/yum/dnf, система инициализации systemd, а также существенно сокращён список используемых стандартных утилит.

***Прежде чем использовать образы с тегом slim и alpine, необходимо тщательно протестировать ваши приложения на этих образах, чтобы убедиться, что написанная программа работает без сбоев.***
</details>

## 2) Множественный RUN(или же МИНИмизация количества слоев образа)

При использовании таких команд как `RUN`, `COPY`, `ADD` Docker созает слои. Каждый слой увеличивает размер образа, так как слои кэшируются.

### Как исправить?

Чтобы уменьшить количество слоев, нужно объединять команды в цепочки для того, чтобы исключить проблемы, связанные с неправильным использованием кэша. 


## 3) Отстутствие кэша пакетов

Устанавливая пакеты, в той же команде стоит очищать кэш, так как это может уменьшить размер образа. 

## Как это исправить?

Добаляем `rm -rf /var/lib/apt/lists/*` к RUN.
Эта директория используется менеджером пакетов APT в ОС на базе Ubuntu и Debian.
Когда Вы выполняете команду `sudo apt update`, APT загружает с серверов-репозиториев информацию о доступных пакетах, их версиях, зависимостях и т.д.
Эти данные сохраняются в виде файлов директории `rm -rf /var/lib/apt/lists/*`. По сути это кэш методанных о пакетах из репозиториев.


```
  _____________
< Hello Lab2! >
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```


# Все плохо с контейнером

### 1) Не надо хранить данные внутри контейнера

В ходе жизненного цикла контейнеры могут приостанавливаться, заменяться или уничтожаться.
Все данные, записанные внутрь контейнера (в его файловую систему), теряются навсегда. Когда контейнер перезапускается или удаляется, он запускается с чистого листа, с тем образом, который был указан при создании.


### 2) Не открывайте UNIX-сокет

Этот сокет является точкой для входа в API. Открыв сокет по адресу /var/run/docker.sock, вы предоставляете неограниченный доступ к хосту с правами root. Следите, чтобы остальные контейнеры не получили доступ, это очень важный параметр безопасности.

  
### 3) Не включайте секреты и учетные сведения

Изначально любой пользователь, который имеет доступ к образу, может получить сведения о секретах, записанные в Dockerfiles. Чтобы этого не произошло, для хранения секретной информации нужно использовать Docker BuildKit, а в командной строке указывать опцию --secret.

## Создание образов и запуск контейнеров
### Хороший-плохой Dockerfile
плохой образ
<img width="1376" height="122" alt="image" src="https://github.com/user-attachments/assets/03764de5-1e11-4526-9775-bd36944ece29" />
<img width="2482" height="340" alt="image" src="https://github.com/user-attachments/assets/3bc55c47-0d33-48ee-89b1-3c64599f29a8" />
т.е. контейнер был создан, но сразу завершил работу, что печально

с хорошим
<img width="2816" height="926" alt="image" src="https://github.com/user-attachments/assets/47b5b825-580f-4391-b23e-39245dfde1ed" />
можно заметить, что вес образа сильно меньше
<img width="2502" height="562" alt="image" src="https://github.com/user-attachments/assets/5053a1a8-c6bf-462e-b779-7c23865e6f80" />
контейнер отработал и поздоровался с лабораторной

### Плохая работа с хорошим Dockerfile
1. Хранение данных внутри контейнера
<img width="2448" height="344" alt="image" src="https://github.com/user-attachments/assets/a9b29e1c-3636-4827-ac55-378cb10eb053" />
интерактивная работа с контейнером, поэтому корова не запустилась
2. Открываем UNIX-сокет

